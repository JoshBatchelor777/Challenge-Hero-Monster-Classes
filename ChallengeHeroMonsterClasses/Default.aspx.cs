using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace ChallengeHeroMonsterClasses
{
    public partial class Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            // Initialize two new characters.
            Character Hodges = new Character();
            Hodges.Name = "Hodges";
            Hodges.Health = 100;
            Hodges.DamageMaximum = 50;
            Hodges.AttackBonus = false;
            Character DrEvil = new Character();
            DrEvil.Name = "Dr. Evil";
            DrEvil.Health = 100;
            DrEvil.DamageMaximum = 50;
            DrEvil.AttackBonus = true;

            // Create New Instance of Dice.
            Dice cube = new Dice();

            // Attack Bonus Logic
            if (DrEvil.AttackBonus) // Defaults to true.
                                    // If DrEvil gets a bonus attack, subtract another
                                    // iteration of the Attack() calculation from the 
                                    // Hero's Health stat.
                Hodges.Defend(DrEvil.Attack(cube));
            if (Hodges.AttackBonus)
                DrEvil.Defend(Hodges.Attack(cube));

            while (Hodges.Health > 0 && DrEvil.Health > 0)
            {
                // Instead of initiating one round to determine each
                // sides health, make it ongoing until one side is dead.

                // The logic below works without making an int to hold the
                // value of damage because the loop is doing everything
                // under the constraints of each player's health being above 0.


                // Explained by this code:
                // While Hodges' health isn't 0, Calculate DrEvil's health as it
                // relates to the number randomly generated by Hodges' Attack() method.
                DrEvil.Defend(Hodges.Attack(cube));
                Hodges.Defend(DrEvil.Attack(cube));

                // And pass that figure through the printStats function.
                printStats(Hodges);
                printStats(DrEvil);
            }
            // After the While Loop, and at the end of the Default Page_Load, 
            // call the displayResults Helper method and do the functionality of it,
            // for the two opponents.
            displayResults(Hodges, DrEvil);
        }

        private void displayResults(Character opponent1, Character opponent2)
        {
            if (opponent1.Health < 0)
                resultLabel.Text += String.Format("{0} is Dead. {1} wins!", opponent2.Name, opponent1.Name);
            else if (opponent2.Health < 0)
                resultLabel.Text += String.Format("{0} is Dead. {1} wins!", opponent1.Name, opponent2.Name);
            else if (opponent1.Health == 0 && opponent2.Health == 0)
                resultLabel.Text += String.Format("{0} and {1} killed each other. It's a Draw!", opponent1.Name, opponent2.Name);


            /*
            // Decide Outcome
            if (DrEvil.Health < 1)
                resultLabel.Text = String.Format("{0} Wins! <br />" + "{1} remaining",
                    Hodges.Name, Hodges.Health.ToString());
            else if (Hodges.Health < 1)
                resultLabel.Text = String.Format("{0} Wins! <br />" + "{1} remaining",
                    DrEvil.Name, DrEvil.Health.ToString());

            */
        }

        // I'm assuming this Helper Method passes in a new character instance
        // because by doing so, it can retreive the properties of every
        // "Character", and assign it to a new character called "character".
        // Confirmed: because this is just a functionality for printing
        // things to the screen. I can call it (as seen above) and tell it
        // to execute this functionality to any different instance from the "Character" class.
        private void printStats(Character character)
        {
            // Using '+=' here tell the app to print for each time it's needed.. not just once.
            resultLabel.Text += String.Format("<p>Name: {0} - Health: {1} - DamageMaximum: {2} - AttackBonus: {3}</p>",
                character.Name,
                character.Health.ToString(),
                character.DamageMaximum.ToString(),
                character.AttackBonus.ToString());
        }

    }

    class Dice
    {
        public int Sides { get; set; }

        Random random = new Random();
        public int Roll()
        {
            int DiceRollValue = random.Next(this.Sides);
            return DiceRollValue;
        }
    }

    class Character
    {
        public string Name { get; set; }
        public int Health { get; set; }
        public int DamageMaximum { get; set; }
        public bool AttackBonus { get; set; }

        public int Attack(Dice cube)
        {
            // My new Dice object, called 'cube'.
            // Attack now returns the value of the power of
            // an attack via the cube.Roll() event(or method).
            // For Example: If the Hero has a max damage of 50,
            // "cube" now has 50 sides. 
            // So in the random Logic, found in the Roll() method of Dice,
            // that's saying to generate a value from 1 to whatever Sides is
            // (50 in this case).
            cube.Sides = this.DamageMaximum;
            return cube.Roll();

            // Generate the power of the first attack
            //int rndDamageValue = rndDamage.Next(this.DamageMaximum);
            //return rndDamageValue;
        }

        public void Defend(int damage)
        {
            // Very simple: The Health property is the Health property 
            // minus the value of damage.
            this.Health -= damage;
        }
    }
}